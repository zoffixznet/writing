# Perl 6 Types: Made for Humans

In my first college programming course, I was taught that Pascal language
has `Integer`, `Boolean`, and `String` types among others. I learned the types
were there because computers were stupid. While dabbing in C, I learned more
about what `int`s, `char`s, and other vermin looked like inside the warm
buzzing metal box under my desk.

Perl 5 didn't have types, and I felt free as a kid on a bike, rushing through
the wind down a slope. No longer did I have to cram my mind into the narrow
slits computer hardware dictated me to. I had *data* and I could do whatever I
wanted with it, as long as I didn't get the wrong kind of data. And when I did
get it, I felt off my bike and skinned my knees.

With Perl 6, you can have the cake and eat it too. You can use types or avoid
them. You can have broad types that accept many kinds of values, or narrow ones.
And you can enjoy the speed of types that represent the mind of the machine, or
you can enjoy the precision of your own custom types that represent your mind,
the types made for humans.

## Gradual Typing

```perl6
    my       $a = 'whatever';
    my Str   $b = 'strings only';
    my Str:D $c = 'defined strings only';
    my int   $d = 16; # native int

    sub foo ($x) { $x + 2 }
    sub foo (Int:D $x) returns Int { $x + 2 }
```

Perl 6 has gradual typing, which means you can either use types or avoid them.
So why bother with them at all?

First, types restrict the range of values that can be contained in your
variable, accepted by your method or sub or returned by them.
This functions both as data validation and as a safety net for garbage data
generated by incorrect code.

Also, you can get better performance and reduced memory usage when using native,
machine-mind types, providing they're the appropriate tool for your data.

## Built-In Types

There's a veritable smörgåsbord of [built-in types in Perl 6](http://docs.perl6.org/type.html). If the thing your subroutine does makes
sense to be done only on integers, use an [Int](http://docs.perl6.org/type/Int).
If negatives don't make sense either, limit the range of values even further
and use an `UInt`—an unsigned `Int`. On the other hand, if you want to handle
a broader range, [`Numeric`](http://docs.perl6.org/type/Numeric) type may
be more appropriate.

If you want to drive closer to the metal, Perl 6 also offers a range of
native types that map into what you'd normally find with, say, `C`. Using these
may offer performance improvements or lower memory usage. The available types
are: `int`, `int8`, `int16`, `int32`, `int64`, `uint, ``uint8`, `uint16`, `uint32`, `uint64`, `num`, `num32`, `num64`. The number in the type name
signifies the available bits, with the numberless types being
platform-dependent.

## Smileys

```perl6
    multi foo (Int:U $x) { 'Y U NO define $x?'         }
    multi foo (Int:D $x) { "The square of $x is {$x²}" }

    my Int $x;
    say foo $x;
    $x = 42;
    say foo $x;

    # OUTPUT:
    # Y U NO define $x?
    # The square of 42 is 1764
```

Smileys are `:U`, `:D`, or `:_` appended to the type name. The `:_` is the
default you get when you don't specify a smiley. The `:U` specifies `undefined
values only`, while `:D` specifies `defined values only`.

This can be useful to detect whether a method is called on a class or on the
instance by having two multies with `:U` and `:D` on the invocant. And if you
work at the nuclear powerplant, ensuring your rod insertion subroutine never
tries to insert by an undefined amount is also a fine thing, I imagine.

## Subsets and Custom Types
